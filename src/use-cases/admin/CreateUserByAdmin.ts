import { IUserRepository } from '../../domain/repositories/IUserRepository';
import { IRoleRepository } from '../../domain/repositories/IRoleRepository';
import { IDepartmentRepository } from '../../domain/repositories/IDepartmentRepository';
import { UserEntity } from '../../domain/entities/User';
import { UserStatus, Gender } from '@prisma/client';
import { logAuditAction } from '../../infrastructure/database/supabaseClient';
import crypto from 'crypto';

export interface CreateUserByAdminRequest {
  // Required fields
  name: string;
  email: string;
  nip: string;
  
  // Optional fields
  phone?: string;
  birthDate?: Date;
  gender?: Gender;
  address?: string;
  hireDate?: Date;
  departmentId?: string;
  roleId?: string;
  
  // Admin context
  adminUserId: string;
  ipAddress?: string;
  userAgent?: string;
  
  // Password options
  generatePassword?: boolean;
  customPassword?: string;
}

export interface CreateUserByAdminResponse {
  success: boolean;
  user?: UserEntity;
  temporaryPassword?: string;
  error?: string;
}

export class CreateUserByAdmin {
  constructor(
    private userRepository: IUserRepository,
    private roleRepository: IRoleRepository,
    private departmentRepository: IDepartmentRepository
  ) {}

  async execute(request: CreateUserByAdminRequest): Promise<CreateUserByAdminResponse> {
    try {
      // Validate admin permissions (this should be done at API level too)
      const adminUser = await this.userRepository.findWithRoleAndDepartment(request.adminUserId);
      if (!adminUser || !this.hasAdminPermissions(adminUser.role?.name)) {
        return { success: false, error: 'Unauthorized: Admin permissions required' };
      }

      // Validate input data
      const validationError = await this.validateInput(request);
      if (validationError) {
        return { success: false, error: validationError };
      }

      // Check for existing users
      const existingUser = await this.checkExistingUser(request);
      if (existingUser) {
        return { success: false, error: existingUser };
      }

      // Validate role and department if provided
      if (request.roleId) {
        const role = await this.roleRepository.findById(request.roleId);
        if (!role || !role.isActive) {
          return { success: false, error: 'Invalid or inactive role selected' };
        }
      }

      if (request.departmentId) {
        const department = await this.departmentRepository.findById(request.departmentId);
        if (!department || !department.isActive) {
          return { success: false, error: 'Invalid or inactive department selected' };
        }
      }

      // Generate password
      const password = request.customPassword || this.generateSecurePassword();

      // Create user entity
      const user = new UserEntity(
        '', // Will be generated by database
        request.email,
        request.name,
        request.nip,
        request.phone,
        request.birthDate,
        request.gender,
        request.address,
        request.hireDate || new Date(),
        UserStatus.ACTIVE,
        request.departmentId,
        request.roleId
      );

      // Set password
      await user.setPassword(password);

      // Save user
      const createdUser = await this.userRepository.create(user);

      // Log audit action
      await this.logUserCreation(request, createdUser);

      return {
        success: true,
        user: createdUser,
        temporaryPassword: request.generatePassword !== false ? password : undefined
      };

    } catch (error) {
      console.error('Error creating user by admin:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to create user' 
      };
    }
  }

  private hasAdminPermissions(roleName?: string): boolean {
    return ['Admin', 'Super Admin', 'HR Admin'].includes(roleName || '');
  }

  private async validateInput(request: CreateUserByAdminRequest): Promise<string | null> {
    // Validate required fields
    if (!request.name?.trim()) {
      return 'Name is required';
    }

    if (!request.email?.trim()) {
      return 'Email is required';
    }

    if (!request.nip?.trim()) {
      return 'NIP is required';
    }

    // Validate email format
    if (!UserEntity.validateEmail(request.email)) {
      return 'Invalid email format';
    }

    // Validate NIP format
    if (!UserEntity.validateNIP(request.nip)) {
      return 'Invalid NIP format (must be 18 digits)';
    }

    // Validate phone if provided
    if (request.phone && !UserEntity.validatePhone(request.phone)) {
      return 'Invalid phone format';
    }

    // Validate custom password if provided
    if (request.customPassword && request.customPassword.length < 8) {
      return 'Custom password must be at least 8 characters long';
    }

    return null;
  }

  private async checkExistingUser(request: CreateUserByAdminRequest): Promise<string | null> {
    // Check email
    const existingEmail = await this.userRepository.findByEmail(request.email);
    if (existingEmail) {
      return 'User with this email already exists';
    }

    // Check NIP
    const existingNIP = await this.userRepository.findByNIP(request.nip);
    if (existingNIP) {
      return 'User with this NIP already exists';
    }

    // Check phone if provided
    if (request.phone) {
      const existingPhone = await this.userRepository.findByPhone(request.phone);
      if (existingPhone) {
        return 'User with this phone number already exists';
      }
    }

    return null;
  }

  private generateSecurePassword(): string {
    // Generate a secure random password
    const length = 12;
    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
    let password = '';
    
    for (let i = 0; i < length; i++) {
      const randomIndex = crypto.randomInt(0, charset.length);
      password += charset[randomIndex];
    }
    
    return password;
  }

  private async logUserCreation(request: CreateUserByAdminRequest, createdUser: UserEntity): Promise<void> {
    try {
      await logAuditAction({
        userId: request.adminUserId,
        action: 'USER_CREATED_BY_ADMIN',
        tableName: 'users',
        recordId: createdUser.id,
        newValues: {
          name: createdUser.name,
          email: createdUser.email,
          nip: createdUser.nip,
          departmentId: createdUser.departmentId,
          roleId: createdUser.roleId,
          status: createdUser.status,
          createdBy: request.adminUserId
        },
        ipAddress: request.ipAddress,
        userAgent: request.userAgent
      });
    } catch (error) {
      console.error('Error logging user creation:', error);
    }
  }
}
